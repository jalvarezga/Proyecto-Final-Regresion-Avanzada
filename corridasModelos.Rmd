# Cargamos paquetes necesarios

```{r}
# Load necessary packages
library(R2OpenBUGS)
library(methods)

source(paste0(getwd(), "/paqueteTecnico/claseNietoBUGS.R"))
```

# Estructura de creación de modelos

## DEFINICIÓN DEL MODELO
```{r}
## NO CORRER

# 1.-SE CREAN VARIABLES DATA, INITS, PARAMETERS
# 2.- SE ESCRIBE EL MODELO
modelCode <- "modelo escrico en el txt" #todavia no corrijo cómo hacer con el caso normalito
# 3.- SE INSTANCIA TODO PARA CORRER EL MODELO CON LOS PARÁMETROS QUE QUEREMOS EN LA SIMULACIÓN
modelo.sim <- bugsModel$new(data, inits, parameters, modelCode1,n.thin=1, n.iter=10000, n.burnin=1000)
# 4.- SE CORRE EL MODELO
modelo.sim$runBugsModel()
```
## CHECAR CONVERGENCIA
```{r}
# TRACEPLOT
modelo.sim$bugsTraceplot()
# CHECA LOS PLOTS DE LA CADENA PARA UN CIERTO PARÁMETRO EN PARAMA
# SI NO SE SABE EN QUÉ ORDEN ESTÁN LOS PARAMS, CORRER EL SEGUNDO CÓDIGO
modelo.sim$graphConvergence(parama=5)

# SUMMARY DE TODAS LAS VARS TRACKEADAS
modelo.sim$summaryModel()

# DIC DEL MODELO
modelo.sim$dicModelfunc()

#tabla resumen 

modelo.sim$resumenfunc() #no se ha checado
```

## REALIZAR MÁS GRÁFICAS...
NOTA:
Lo que más se usa es out.sum, el cual sale de modelo.sim$summModel
Cualquier otro parámetro checar en paqueteTecnico.

```{r}

##CHECAR EN QUÉ NOS PUEDE SERVIR ESTE CÓDIGO
#w
out.w<-out.sum[grep("w",rownames(out.sum)),]
out.w<-out.w[-nrow(out.w),]
out.est<-out.w
k<-n
ymin<-min(out.est[,c(1,3,7)])
ymax<-max(out.est[,c(1,3,7)])
par(mfrow=c(1,1))
plot(1:k,out.est[,1],xlab="index",ylab="",ylim=c(ymin,ymax))
segments(1:k,out.est[,3],1:k,out.est[,7])
abline(h=0,col="grey70")
title("Efecto espacial")

#Predictions
out.yf<-out.sum[grep("yf1",rownames(out.sum)),]
#longitude
or<-order(s1)
ymin<-min(y,out.yf[,c(1,3,7)])
ymax<-max(y,out.yf[,c(1,3,7)])
par(mfrow=c(1,1))
plot(s1,y,ylim=c(ymin,ymax),xlab="longitude")
points(s1[or],out.yf[or,1],pch=20,col=2)
segments(s1[or],out.yf[or,3],s1[or],out.yf[or,7],col=2)
#latitude
or<-order(s2)
ymin<-min(y,out.yf[,c(1,3,7)])
ymax<-max(y,out.yf[,c(1,3,7)])
par(mfrow=c(1,1))
plot(s2,y,ylim=c(ymin,ymax),xlab="latitude")
points(s2[or],out.yf[or,1],pch=20,col=2)
segments(s2[or],out.yf[or,3],s2[or],out.yf[or,7],col=2)
#
plot(y,out.yf[,1])
R2<-(cor(scallop$lgcatch,out.yf[,1]))^2
print(R2)
#map
map("usa",xlim=c(-74,-71),ylim=c(38.2,41.5))
int.scp<-interp(s1,s2,out.yf[,1])
contour(int.scp,add=TRUE)
image(int.scp,add=TRUE)

#Future predictions
out.yf2<-out.sum[grep("yf2",rownames(out.sum)),]
print(out.yf2[,c(1,3,7)])
```

# MODELOS CORRIDOS

## Cargamos datos iniciales
```{r}
# tomamos valores de regresores
```

```{r}
source(paste0(getwd(), "/pruebasMSR.R"))
# número de registros 
n<-length(vector_yi) 

# variable de respuesta para cada distrito
y<- vector_yi

# valores de los regresiones para cada distrito asociadas a una coordenada
#x <- cbind(data_indices$indice_edades, data_indices$indice_educacion, data_indices$indice_movilidad, data_indices$indice_raza), FUN=quitarPorcentaje, MARGIN=2))
x<-cbind(data_indices$indice_edades, data_indices$indice_educacion, data_indices$indice_movilidad, data_indices$indice_raza,data_percapita$Per.Capita.Income,quitarPorcentaje(data_pobreza$Poverty.rate))

#coordenadas de las regiones i

s1 <- coordenadas$Longitude
s2 <- coordenadas$Latitude

# valores a predecir en el modelo en una coordenada nueva
#elegimos distrito a predecir
set.seed(123)
nAleExc <- sample(1:22, size = 2, replace = FALSE)

s1f<-s1[nAleExc]
s2f<-s2[nAleExc]

m <- 2

# Defining data of the model
data<-list("n"=n,"y"=y,"x"=x,"s1"=s1[-nAleExc],"s2"=s2[-nAleExc],"m"=m,"s1f"=s1f,"s2f"=s2f)

#-Defining inits-
inits<-function(){list(beta=rep(0,7),tau=1,w=rep(0,n),tau.w=1,phi=1,yf1=rep(0,n),wf=rep(0,m),yf2=rep(0,m))}

#-Selecting parameters to monitor-
parameters<-c("beta","tau","w","tau.w","phi","yf1","yf2")

```

# Modelo 1

con índices (Modelo de Diego)

```{r}
modelCode1 <- "model
{
#Likelihood
for (i in 1:n) {
	y[i] ~ dnorm(mu[i],tau)
	mu[i]<-w[i]+beta[1]+beta[2]*x[i,1]+beta[3]*x[i,2]+beta[4]*x[i,3]+beta[5]*x[i,4]+beta[6]*x[i,5]+beta[7]*x[i,6]
	w0[i]<-0
	}

#Priors 
for (j in 1:7) { beta[j] ~ dnorm(0,0.001) }
tau ~ dgamma(0.1,0.1)
w[1:n] ~ spatial.exp(w0[],s1[],s2[],tau.w,phi,1)
tau.w ~ dgamma(0.1,0.1)
phi ~ dgamma(0.1,0.1)

#Prediction 1
for (i in 1:n) { yf1[i] ~ dnorm(mu[i],tau) }
#Prediction 2
#wf[1:m] ~ spatial.pred(w0f[],s1f[],s2f[],w[])
for (i in 1:m) { 
	yf2[i] ~ dnorm(muf[i],tau) 
	muf[i]<-alpha+wf[i]
	w0f[i]<-0
	wf[i] ~ spatial.unipred(w0f[i],s1f[i],s2f[i],w[])
}

}" 

modelo.sim <- bugsModel$new(data, inits, parameters, modelCode1,n.thin=5, n.iter=10000, n.burnin=1000)

modelo.sim$runBugsModel()
```

## Checamos convergencia
```{r}
modelo.sim$graphConvergence(parama=5)

modelo.sim$summaryModel()

modelo.sim$dicModelfunc()

modelo.sim$resumenfunc()
```

## Graficamos resultados

```{r}

```

# Modelo 2

sin índices (Modelo de Joaquín completo)
```{r}
# recreación de matriz de regresores
x<-cbind(data_percapita$Per.Capita.Income,quitarPorcentaje(data_pobreza$Poverty.rate),..)
```
```{r}
modelCode2 <- "model
{
#Likelihood
for (i in 1:n) {
	y[i] ~ dnorm(mu[i],tau)
	mu[i]<-w[i]+beta[1]+beta[2]*x[i,1]+beta[3]*x[i,2]+beta[4]*x[i,3]+beta[5]*x[i,4]+beta[6]*x[i,5]+beta[7]*x[i,6]
	w0[i]<-0
	}

#Priors 
for (j in 1:7) { beta[j] ~ dnorm(0,0.001) }
tau ~ dgamma(0.1,0.1)
w[1:n] ~ spatial.exp(w0[],s1[],s2[],tau.w,phi,1)
tau.w ~ dgamma(0.1,0.1)
phi ~ dgamma(0.1,0.1)

#Prediction 1
for (i in 1:n) { yf1[i] ~ dnorm(mu[i],tau) }
#Prediction 2
#wf[1:m] ~ spatial.pred(w0f[],s1f[],s2f[],w[])
for (i in 1:m) { 
	yf2[i] ~ dnorm(muf[i],tau) 
	muf[i]<-alpha+wf[i]
	w0f[i]<-0
	wf[i] ~ spatial.unipred(w0f[i],s1f[i],s2f[i],w[])
}

}" 

modelo2.sim <- bugsModel$new(data, inits, parameters, modelCode2,n.thin=5, n.iter=10000, n.burnin=1000)

modelo2.sim$runBugsModel()
```

## Checamos convergencia
```{r}
modelo2.sim$graphConvergence(parama=5)

modelo2.sim$summaryModel()

modelo2.sim$dicModelfunc()

modelo2.sim$resumenfunc()
```

## Graficamos resultados

```{r}

```
